---
export const title = "Webカメラ照準器";
export const description = "スマホなどを照準器にできるWebアプリです。";
import "@/styles/reset.css";
import "@/styles/campbell.css";
import Head from "@/components/Head.astro";
---

<!doctype html>
<html lang="ja">
    <Head title={title} description={description}>
        <link rel="manifest" href="manifest.webmanifest" />
    </Head>
    <body>
        <video id="liveView" muted playsinline> </video>
        <canvas id="sight" width="0" height="0"></canvas>
        <div id="settings">
            <span>画角/換算mm</span>
            <label for="focalLV">表示</label><input type="number" inputmode="numeric" id="focalLV" value="30" />
            <label for="focalSight">照準</label><input type="number" inputmode="numeric" id="focalSight" value="100" />
            <label for="ratioSight">縦横比</label><input type="number" inputmode="decimal" id="ratioSight" value="1.5" />
            <button id="initParallax">視差初期化</button>
        </div>
        <div id="message">カメラ起動中</div>
        <script>
            const liveView = document.getElementById("liveView")! as HTMLVideoElement;
            const sight = document.getElementById("sight")! as HTMLCanvasElement;
            const message = document.getElementById("message")! as HTMLDivElement;

            const focalLV = document.getElementById("focalLV") as HTMLInputElement;
            const focalSight = document.getElementById("focalSight") as HTMLInputElement;
            const ratioSight = document.getElementById("ratioSight") as HTMLInputElement;
            const initParallax = document.getElementById("initParallax") as HTMLButtonElement;

            new ResizeObserver(async () => {
                sight.width = liveView.clientWidth;
                sight.height = liveView.clientHeight;
                await drawSight(); // キャンバスサイズが変わると描画が消えるので再描画
            }).observe(liveView);

            addEventListener("load", async () => {
                loadSettings();
                await setLiveViewSource()
                    .then(async () => {
                        await liveView.play().catch(() => {
                            message.textContent = "クリックしてカメラを起動";
                            message.addEventListener("click", () => liveView.play());
                        });
                    })
                    .catch(() => {
                        message.textContent = "クリックしてカメラを許可";
                        message.addEventListener("click", async () => {
                            await setLiveViewSource().then(() => liveView.play());
                        });
                    });
            });

            liveView.addEventListener("play", async () => {
                message.remove();
            });

            focalLV.addEventListener("input", async () => {
                Settings.focalLV = Number(focalLV.value);
                await drawSight();
            });
            focalSight.addEventListener("input", async () => {
                Settings.focalSight = Number(focalSight.value);
                await drawSight();
            });
            ratioSight.addEventListener("input", async () => {
                Settings.ratioSight = Number(ratioSight.value);
                await drawSight();
            });
            initParallax.addEventListener("click", async () => {
                Settings.parallax = { x: 0, y: 0 };
                await drawSight();
            });

            function loadSettings() {
                Settings.focalLV ? (focalLV.value = Settings.focalLV.toString()) : (Settings.focalLV = Number(focalLV.value));
                Settings.focalSight ? (focalSight.value = Settings.focalSight.toString()) : (Settings.focalSight = Number(focalSight.value));
                Settings.ratioSight ? (ratioSight.value = Settings.ratioSight.toString()) : (Settings.ratioSight = Number(ratioSight.value));
                Settings.parallax ? undefined : (Settings.parallax = { x: 0, y: 0 });
            }

            async function setLiveViewSource() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: {
                        facingMode: "environment",
                        width: 9999,
                        height: 9999,
                    },
                });
                liveView.srcObject = stream;
            }

            async function drawSight() {
                const focalLVMilimeter = Settings.focalLV;
                const focalSightMilimeter = Settings.focalSight;
                const ratioSight = Settings.ratioSight;
                const distanceMeter = Number.MAX_SAFE_INTEGER;

                const fovLV = getFullframeFovMilimeter(focalLVMilimeter, liveView.clientWidth / liveView.clientHeight, distanceMeter);
                const fovSight = getFullframeFovMilimeter(focalSightMilimeter, ratioSight, distanceMeter);
                const parallax = Settings.parallax;

                const pxPerMilimeter = sight.width / fovLV.x;
                const context = sight.getContext("2d")!;
                context.clearRect(0, 0, sight.width, sight.height);
                context.strokeStyle = "red";
                context.lineWidth = 2;
                context.beginPath();
                context.rect((fovLV.x / 2 - fovSight.x / 2 - parallax.x) * pxPerMilimeter, (fovLV.y / 2 - fovSight.y / 2 - parallax.y) * pxPerMilimeter, fovSight.x * pxPerMilimeter, fovSight.y * pxPerMilimeter);
                context.stroke();
            }

            function getFullframeFovMilimeter(focalMilimeter: number, aspectRatio: number, distanceMeter: number): { x: number; y: number } {
                const diagonalMilimeter = Math.sqrt(24 ** 2 + 36 ** 2) * ((distanceMeter * 1000) / focalMilimeter);
                const diagonalRadian = Math.atan2(1, aspectRatio);
                return {
                    x: diagonalMilimeter * Math.cos(diagonalRadian),
                    y: diagonalMilimeter * Math.sin(diagonalRadian),
                };
            }

            class Settings {
                public static get focalLV(): number {
                    return this.localStorageSettings.focalLV;
                }
                public static set focalLV(focalLV: number) {
                    const newSettings = this.localStorageSettings;
                    newSettings.focalLV = Math.max(1, focalLV);
                    this.localStorageSettings = newSettings;
                }
                public static get focalSight(): number {
                    return this.localStorageSettings.focalSight;
                }
                public static set focalSight(focalSight: number) {
                    const newSettings = this.localStorageSettings;
                    newSettings.focalSight = Math.max(1, focalSight);
                    this.localStorageSettings = newSettings;
                }
                public static get ratioSight(): number {
                    return this.localStorageSettings.ratioSight;
                }
                public static set ratioSight(ratioSight: number) {
                    const newSettings = this.localStorageSettings;
                    newSettings.ratioSight = ratioSight;
                    this.localStorageSettings = newSettings;
                }
                public static get parallax(): { x: number; y: number } {
                    return this.localStorageSettings.parallax;
                }
                public static set parallax(parallax: { x: number; y: number }) {
                    const newSettings = this.localStorageSettings;
                    newSettings.parallax = parallax;
                    this.localStorageSettings = newSettings;
                }

                private static get localStorageSettings() {
                    return JSON.parse(localStorage.getItem("settings") ?? "{}");
                }
                private static set localStorageSettings(settings) {
                    console.log(settings);
                    localStorage.setItem("settings", JSON.stringify(settings));
                }
            }
        </script>
        <style lang="scss">
            :root {
                color-scheme: dark;
                --background-color: var(--black);
                --main-shadow: var(--bblack);
                --main-color: var(--bwhite);
                --sub-color: var(--white);
                --link-color: var(--byellow);

                @media (prefers-color-scheme: light) {
                    color-scheme: light;
                    --background-color: var(--bwhite);
                    --main-shadow: var(--white);
                    --main-color: var(--black);
                    --sub-color: var(--bblack);
                    --link-color: var(--blue);
                }
            }
            body {
                overflow: hidden;
                color: var(--main-color);
                width: fit-content;
                height: fit-content;
            }
            video#liveView {
                position: static;
                max-width: 100lvw;
                max-height: 100lvh;
            }
            canvas#sight {
                position: absolute;
                z-index: 1;
                top: 0;
                left: 0;
            }
            div#settings {
                position: absolute;
                z-index: 2;
                bottom: 0;
                left: 0;
                // display: none;
                * {
                    margin: 0.25em;
                }
                label {
                    text-shadow: 0 0 2px var(--background-color);
                }
                input[type="number"] {
                    width: 3em;
                }
            }
            div#message {
                position: absolute;
                z-index: 3;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: var(--background-color);
                text-align: center;
                align-content: center;
            }
        </style>
    </body>
</html>
