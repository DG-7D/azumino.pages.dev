---
export const title = "Webカメラ照準器";
export const description = "スマホなどを照準器にできるWebアプリです。";
import "@/styles/reset.css";
import "@/styles/campbell.css";
import Head from "@/components/Head.astro";
---

<!doctype html>
<html lang="ja">
    <Head title={title} description={description}>
        <link rel="manifest" href="manifest.webmanifest" />
    </Head>
    <body>
        <video id="liveView" muted playsinline> </video>
        <canvas id="sight" width="0" height="0"></canvas>
        <div id="message" style="display:none;">ライブビューを開始するにはクリックしてください</div>
        <div id="settings">
            <span>画角/換算mm</span>
            <label for="focalLV">表示</label><input type="number" inputmode="numeric" id="focalLV" value="30" />
            <label for="focalSight">照準</label><input type="number" inputmode="numeric" id="focalSight" value="100" />
            <label for="ratioSight">縦横比</label><input type="number" inputmode="decimal" id="ratioSight" value="1.5" />
            <label for="distance">撮影距離/m (0:無限遠)</label><input type="number" inputmode="decimal" id="distance" value="0" />
            <span>視差/mm</span>
            <label for="parallaxX">右</label><input type="number" inputmode="text" id="parallaxX" value="0" />
            <label for="parallaxY">上</label><input type="number" inputmode="text" id="parallaxY" value="0" />
        </div>
        <script>
            function getFullframeFovMilimeter(focalMilimeter: number, aspectRatio: number, distanceMeter: number): { x: number; y: number } {
                const diagonalMilimeter = (Math.sqrt((24 ^ 2) + (36 ^ 2)) * distanceMeter * 1000) / focalMilimeter;
                const diagonalRadian = Math.atan2(1, aspectRatio);
                return {
                    x: diagonalMilimeter * Math.cos(diagonalRadian),
                    y: diagonalMilimeter * Math.sin(diagonalRadian),
                };
            }
            const localStorageNumber = {
                setItem: function (key: string, value: number): void {
                    localStorage.setItem(key, value.toString());
                },
                getItem: function (key: string): number {
                    return Number(localStorage.getItem(key));
                },
            };

            const liveView = document.getElementById("liveView")! as HTMLVideoElement;
            const sight = document.getElementById("sight")! as HTMLCanvasElement;

            const getInputElementById = (id: string) => document.getElementById(id)! as HTMLInputElement;
            const focalLV = getInputElementById("focalLV");
            const focalSight = getInputElementById("focalSight");
            const ratioSight = getInputElementById("ratioSight");
            const distance = getInputElementById("distance");
            const parallaxX = getInputElementById("parallaxX");
            const parallaxY = getInputElementById("parallaxY");
            const inputs = [focalLV, focalSight, ratioSight, distance, parallaxX, parallaxY];

            addEventListener("load", async () => {
                await setLiveViewSource();
                await liveView
                    .play()
                    .then(syncCanvasSize)
                    .catch(() => {
                        const message = document.getElementById("message")!;
                        message.style.display = "block";
                        message.addEventListener("click", async () => {
                            await liveView.play().then(() => {
                                message.remove();
                            });
                            await syncCanvasSize();
                        });
                    });
                loadSettings();
                await drawSight();
            });

            inputs.forEach(input => {
                input.addEventListener("input", async () => {
                    localStorage.setItem(input.id, input.value);
                    await drawSight();
                });
            });

            addEventListener("orientationchange", async () => {
                await new Promise(resolve => setTimeout(resolve, 500)); // 待たないとiOSで回転が反映されない
                await syncCanvasSize();
            });

            async function setLiveViewSource() {
                const stream = await navigator.mediaDevices.getUserMedia({
                    audio: false,
                    video: {
                        facingMode: "environment",
                        width: 9999,
                        height: 9999,
                    },
                });
                liveView.srcObject = stream;
            }

            async function syncCanvasSize() {
                sight.width = liveView.clientWidth;
                sight.height = liveView.clientHeight;
                await drawSight(); // キャンバスサイズが変わると描画が消えるので再描画
            }

            function loadSettings() {
                inputs.forEach(input => {
                    if (localStorage.getItem(input.id)) {
                        input.value = localStorage.getItem(input.id)!;
                    } else {
                        localStorage.setItem(input.id, input.value);
                    }
                });
            }

            async function drawSight() {
                const focalLVMilimeter = Math.max(1, localStorageNumber.getItem("focalLV"));
                const focalSightMilimeter = Math.max(1, localStorageNumber.getItem("focalSight"));
                const ratioSight = localStorageNumber.getItem("ratioSight");
                const distanceMeter = localStorageNumber.getItem("distance") > 0 ? localStorageNumber.getItem("distance") : Number.MAX_SAFE_INTEGER;

                const fovLV = getFullframeFovMilimeter(focalLVMilimeter, liveView.clientWidth / liveView.clientHeight, distanceMeter);
                const fovSight = getFullframeFovMilimeter(focalSightMilimeter, ratioSight, distanceMeter);
                const parallax = {
                    x: localStorageNumber.getItem("parallaxX"),
                    y: localStorageNumber.getItem("parallaxY"),
                };

                const pxPerMilimeter = sight.width / fovLV.x;
                const context = sight.getContext("2d")!;
                context.clearRect(0, 0, sight.width, sight.height);
                context.strokeStyle = "red";
                context.lineWidth = 2;
                context.beginPath();
                context.rect((fovLV.x / 2 - fovSight.x / 2 - parallax.x) * pxPerMilimeter, (fovLV.y / 2 - fovSight.y / 2 - parallax.y) * pxPerMilimeter, fovSight.x * pxPerMilimeter, fovSight.y * pxPerMilimeter);
                context.stroke();
            }
        </script>
        <style lang="scss">
            :root {
                color-scheme: dark;
                --background-color: var(--black);
                --main-shadow: var(--bblack);
                --main-color: var(--bwhite);
                --sub-color: var(--white);
                --link-color: var(--byellow);

                @media (prefers-color-scheme: light) {
                    color-scheme: light;
                    --background-color: var(--bwhite);
                    --main-shadow: var(--white);
                    --main-color: var(--black);
                    --sub-color: var(--bblack);
                    --link-color: var(--blue);
                }
            }
            body {
                overflow: hidden;
                color: var(--main-color);
                width: fit-content;
                height: fit-content;
            }
            video#liveView {
                position: static;
                max-width: 100lvw;
                max-height: 100lvh;
            }
            canvas#sight {
                position: absolute;
                top: 0;
                left: 0;
                z-index: 1;
            }
            div#message {
                position: absolute;
                z-index: 2;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                text-align: center;
                align-content: center;
            }
            div#settings {
                position: absolute;
                z-index: 3;
                bottom: 0;
                left: 0;
                // display: none;
                * {
                    margin: 0.25em;
                }
                label {
                    text-shadow: 0 0 2px var(--background-color);
                }
                input[type="number"] {
                    width: 3em;
                }
            }
        </style>
    </body>
</html>
