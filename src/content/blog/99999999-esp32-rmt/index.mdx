---
publish: false
title: "ESP32で任意の赤外線リモコン信号を投げられるサーバを作ってみた"
publishDate: 9999-12-31 00:00:00 +09:00
description: "せつめい"
---

人間が生存可能な空間を生成するためにはエアコンが欠かせないわが国であるが、長時間出かけるときにもつけっぱなしというわけにはいかない(短時間であればつけっぱなしのほうが効率的なことはある)。しかし、帰宅してから電源を入れていては、部屋が人間の存在できる環境になるまでに時間がかかってしまう。帰宅時間がある程度予測できるのならタイマを設定しておけばよいが、大学生はいつ帰れるのか分からないがち。イマドキのエアコンであれば、インターネットに繋がっていて外出先からアプリで操作できるようなものもあるが、自室で使っているエアコンは最低限の機能のもので、そんな大層な機能はついていない。

そこで、遠隔操作でリモコンの赤外線信号を発することのできる装置を自作することにした。似たような既製品はないこともないが、材料は工研に転がっているので安く済むし、自作したほうが自由度が高い。

## 

操作はHTTP APIで任意のビット列を送信することで行えるようにする。サーバ用のPCからUARTで投げつけることも考えたが、Windowsでシリアルポートを扱うのは面倒なのでやめた。また、ビット列をマイコンの中に格納するのは面倒なうえに柔軟性も欠くので却下。

LAN接続ができる必要があるので、ESP32を使う。

ESP32はWi-Fiが利用できるだけでなく、Remote Control Transceiver (RMT)という赤外線リモコン信号の送受信に特化したモジュールが搭載されている。

## 赤外線リモコンの形式

赤外線はそこらじゅうに溢れているので、単にHIGH/LOWをLEDのオン/オフに変換しても信号を識別することはできない。HIGHを点灯ではなく特定の周波数での点滅にし、受信側もその周波数でフィルタをかけることで、通信が成立している。振幅偏移変調(ASK)の一種のオンオフ変調(OOK)であり、振幅変調(AM)のデジタル版のようなものである。

ここまではどの赤外線リモコンでも同じだが、0/1とHIGH/LOWとの対応などはいくつかの形式が存在する。

## リモコン解析

エアコンのリモコンがどのような形式で通信しているのかを調べる必要がある。まずは赤外線受信モジュールの信号をオシロスコープで観測し、
開始、終了の信号と、0/1とHIGH/LOWの対応はNEC形式と同じであり、ビット長のみ拡張されていることが分かった。

さらにデータの形式を調べるため、Arduinoを用いて受信器の信号を0/1のビット列に変換できるようにした。色々な方式に対応しようとすると面倒になるが、NEC形式と決め打ちすればかなり簡単にできる。

リモコン側が状態を保持していて毎度全て送信されているため、
ランダムに見える部分があったが、どうやら時刻を保持しているらしいことが分かった。リモコンには時刻設定の機能はないのに、しっかり時と分に分かれていて謎である。さらに、タイマの情報も「時間」ではなく「時刻」で送信されている。

## PlatformIOで最新のArduino-ESP32を使う

送信するデータが用意できたので、送信側を実装する。

ところで、ESP32では比較的低レイヤなESP-IDFというフレームワークのほかに、Arduino-ESP32というArduino IDEでArduinoと同じようにプログラムを書いたりボードに書き込んだりできるようにするための[Arduino-ESP32](https://github.com/espressif/arduino-esp32)というArduino core (APIの実装やツールチェーンとその使い方の情報などを含むプラットフォーム?)が公式に提供されている。Arduino API互換の機能だけでなく、RMTなどESP32固有の機能も抽象化して簡単に使えるようになっている。

Arduinoを扱うことのできる開発環境として、PlatformIOというものもある。Arduino IDEよりも強力で、VSCodeなどと連携して使うことができるなどの利点がある。PlatformIOにもプラットフォームの概念があり、ArduinoCore-avrやATTinyCoreを参照する[AVRマイコン(を搭載するArduinoボード)向け](https://github.com/platformio/platform-atmelavr)のプラットフォーム定義、およびESP-IDFとArduino-ESP32を参照する[ESP32向け](https://github.com/platformio/platform-espressif32)のプラットフォーム定義が公式から提供されている。しかしながら、PlatformIO公式のESP32向けプラットフォームでは、対応するArduinoCore-avrのほうは古いバージョン(v2.x)で止まってしまっている。これはEspressifとPlatformIOの関係が悪化したことが原因らしく、コミュニティが新しいバージョンに対応した[プラットフォーム定義](https://github.com/pioarduino/platform-espressif32)を提供している。

簡単なことをする分には何も考えずPlatformIO公式のESP32プラットフォームで古いArduino環境を使っても特に困ることはない。しかし、RMTについては、仕様がESP-IDF v5.xで[変更されており](https://docs.espressif.com/projects/esp-idf/en/v5.5/esp32/migration-guides/release-5.x/5.0/peripherals.html#rmt-driver)、Arduino-ESP32もそれに[追従している](https://docs.espressif.com/projects/esp-idf/en/v5.5/esp32/migration-guides/release-5.x/5.0/peripherals.html#rmt-driver)ため、バージョンによって使い心地が異なってくる。Arduino v2.0.17ではESP-IDF v4.4.7ベースなので古いRMTのAPIで、公式のプラットフォームでは新しいRMTのAPIを使うことはできず、コミュニティ版のプラットフォームでなら新しいRMTのAPIを使うことができるという状況になっている。

`platform = arduino` → Arduino-ESP32 v2.0.17 (ESP-IDF v4.4.7ベース) → Arduino版旧RMT (旧RMTベース) ドキュメントおしまい
`platform = espidf` → ESP-IDF v5.5.0 (新RMT)
`platform = arduino, espidf` → ESP-IDFが3.4に??? → 旧RMT

Arduino版新RMT realTickなし Carrierまとも

https://note.com/ndenki/n/n35bb7a41bbd8