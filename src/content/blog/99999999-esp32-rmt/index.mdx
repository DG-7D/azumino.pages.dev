---
publish: false
title: "ESP32で任意の赤外線リモコン信号を投げられるサーバを作ってみた"
publishDate: 9999-12-31 00:00:00 +09:00
description: "せつめい"
---

人間が生存可能な空間を生成するためにはエアコンが欠かせないわが国であるが、長時間出かけるときにもつけっぱなしというわけにはいかない(短時間であればつけっぱなしのほうが効率的なことはある)。しかし、帰宅してから電源を入れていては、部屋が人間の存在できる環境になるまでに時間がかかってしまう。帰宅時間がある程度予測できるのならタイマを設定しておけばよいが、大学生はいつ帰れるのか分からないがち。イマドキのエアコンであれば、インターネットに繋がっていて外出先からアプリで操作できるようなものもあるが、自室で使っているエアコンは最低限の機能のもので、そんな大層な機能はついていない。

そこで、遠隔操作でリモコンの赤外線信号を発することのできる装置を自作することにした。似たような既製品はないこともないが、材料は工研に転がっているので安く済むし、自作したほうが自由度が高い。

## 

操作はHTTP APIで任意のビット列を送信することで行えるようにする。サーバ用のPCからUARTで投げつけることも考えたが、Windowsでシリアルポートを扱うのは面倒なのでやめた。また、ビット列をマイコンの中に格納するのは面倒なうえに柔軟性も欠くので却下。

LAN接続ができる必要があるので、ESP32を使う。

ESP32はWi-Fiが利用できるだけでなく、Remote Control Transceiver (RMT)という赤外線リモコン信号の送受信に特化したモジュールが搭載されている。

## 赤外線リモコンの形式

赤外線はそこらじゅうに溢れているので、単にHIGH/LOWをLEDのオン/オフに変換しても信号を識別することはできない。HIGHを点灯ではなく特定の周波数での点滅にし、受信側もその周波数でフィルタをかけることで、通信が成立している。振幅偏移変調(ASK)の一種のオンオフ変調(OOK)であり、振幅変調(AM)のデジタル版のようなものである。

ここまではどの赤外線リモコンでも同じだが、0/1とHIGH/LOWとの対応などはいくつかの形式が存在する。

## リモコン解析

エアコンのリモコンがどのような形式で通信しているのかを調べる必要がある。まずは赤外線受信モジュールの信号をオシロスコープで観測し、
開始、終了の信号と、0/1とHIGH/LOWの対応はNEC形式と同じであり、ビット長のみ拡張されていることが分かった。

さらにデータの形式を調べるため、Arduinoを用いて受信器の信号を0/1のビット列に変換できるようにした。色々な方式に対応しようとすると面倒になるが、NEC形式と決め打ちすればかなり簡単にできる。

リモコン側が状態を保持していて毎度全て送信されているため、
ランダムに見える部分があったが、どうやら時刻を保持しているらしいことが分かった。リモコンには時刻設定の機能はないのに、しっかり時と分に分かれていて謎である。さらに、タイマの情報も「時間」ではなく「時刻」で送信されている。



## RMT

送信するデータが用意できたので、送信側を実装する。

Arduino-ESP32の公式ドキュメントはバージョンの指定ができず、古いv2系の情報を得ることはできない。GitHubで[過去のコミットにあるソース](https://github.com/espressif/arduino-esp32/blob/2.0.17/docs/source/api/rmt.rst)を参照することはできるが、情報量はゼロである。[ソースコード](https://github.com/espressif/arduino-esp32/blob/2.0.17/cores/esp32/esp32-hal-rmt.h)上のコメントにはいくらか情報がある。いくつか[スケッチ例](https://github.com/espressif/arduino-esp32/tree/2.0.17/libraries/ESP32/examples/RMT)もあるが、`esp32-hal.h`をincludeしていたりして、なんだか面倒臭そうということだけが分かる。ベースとなっている[ESP-IDF v4.4.7のドキュメント](https://docs.espressif.com/projects/esp-idf/en/v4.4.7/esp32/api-reference/peripherals/rmt.html)も参考になる。

Arduino-ESP32のv3系であれば[公式ドキュメント](https://docs.espressif.com/projects/arduino-esp32/en/latest/api/rmt.html)をWebで参照することができるが、v2のころと変わらず情報量は皆無である。v2と同じく[ソースコード](https://github.com/espressif/arduino-esp32/blob/master/cores/esp32/esp32-hal-rmt.h)上のコメントから情報を得られるほか、[スケッチ例](https://github.com/espressif/arduino-esp32/tree/master/libraries/ESP32/examples/RMT)のほうもいくらか増えたり読みやすくなったりしており、特に[RMTWrite_RGB_LED](https://github.com/espressif/arduino-esp32/blob/master/libraries/ESP32/examples/RMT/RMTWrite_RGB_LED/RMTWrite_RGB_LED.ino)などはシンプルで取っ付きやすい。ベースとなっている[ESP-IDF v5のドキュメント](https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/peripherals/rmt.html)も参照できる。

先ほどv2系とv3系とでは使い勝手が異なると述べたが、具体的には以下のような違いがある。まず、RMTの時間単位であるTickの設定において、1Tickの長さには制約があるが、v2系では要求したTick長が使えない場合は実際のTick長は勝手に決められ、返り値で実際のTickが返されていたのに対し、v3系では要求したTickが使えない場合は初期化に失敗する(falseが返る)ようになった。また、搬送波の設定において、v2系ではHIGHのTick数とLOWのTick数をそれぞれ計算して指定する必要があったのに対し、v3系では周波数とデューティ比を指定できるようになった。このように、明らかにv3系のほうが使いやすくなっているため、上記のような方法で新しいArduino-ESP32を使えるようにする。

https://note.com/ndenki/n/n35bb7a41bbd8