---
publish: false
title: "Bay Trail-Tで32bit UEFIなMebius Padに64bitなOSを入れてみた"
publishDate: 9999-12-31 00:00:00 +09:00
description: "せつめい"
---

工研にタブレットPCのMebius Padが転がっているのを発見し、少しいじってみた。以前にSigezoneで投げ売りされていたようで、恐らくこの個体もそこで拾われたものと思われる。

長時間放置され電池は空になっていたため、まずは充電する必要がある。USB Micro-ABポートに5 Vをかけてみても充電される様子はなかったので、DCジャックからの充電を試みる。工研にはDCジャックの形状を変換するやつが山ほど転がっているので、適当に合うもの(外径3.0 mm、内径1.1 mm[らしい](https://x.com/ShigezoneAkiba/status/1602203935250743296))を探し出した。本体に12 V 2 Aと書いてあったので、PDトリガケーブルで12 Vを作ってぶちこんでみたところ起動することができた。実測では瞬間最大1.5 A程度だった。

当初は電源に接続してもほぼ充電されず、バッテリが滅びているのかと思ったが、長時間かけて100%まで充電してみたところ、それ以降は普通に充放電できるようになった。過放電しかけて保護機能が動作していたものと思われる。容量は7 %ほど低下していたが、駆動時間は問題ないどころかかなり長い。

正常にWindowsを起動することができたのでスペックを確認したところ、CPUは64bitのAtom Z3770を搭載している一方、ファームウェアは32bitのUEFIであった。Windowsは32bit UEFIでは32bit版しか起動することができず、また、Windows 11には32bit版は存在しないため、このままではWindows 10のサポート終了と共に滅びてしまう。

## CSMWrap経由のWindows

WindowsはUEFIではファームウェアとOSのビット数が一致していなければならないが、レガシBIOSであればそのような制限はない(そもそもレガシBIOSって16bitとかでは?)。Windows 11でもサポート外ではあるがレガシBIOSでの起動が可能であるため、レガシBIOS互換機能のCSMが使えれば64bit版Windowsを起動できる可能性がある。しかし、設定画面を見る限りではMebius PadにはCSMはない。

それでもまだ諦めるには早く、この世にはCSMWrapなるものが存在する。これは、レガシBIOSのエミュレーション機能をUEFIアプリケーションの形で提供するものである。実際に、これを用いて32bit UEFIでWindows 11を起動した例は既に存在する。これを真似てみようと思う。

まず、OSに関係なく、CSMWrapが起動した段階でUSBハブの認識は失われてしまい、その下にあるUSBドライブも使えなくなる。そのため、USBドライブとUSBキーボードは排他になる。

とりあえずインストーラを起動してみたところ、Windows 11 64bitのものを起動することができたが、タッチパネルは効かず、USBドライブを抜いて(PE自体はRAM上で動作していて問題ないはず)USBキーボードを刺しても反応しなかった。

内蔵ドライブにインストール済環境を配置すればUSBキーボードが使用でき検証ができると思われるが、動作環境を完全に破壊するのは気が進まないので、タッチパネルが動作しそうなWindows 10 32bitをUSBドライブにインストールし、CSMWrap経由で起動してみた。狙い通りタッチが使えたのでいじってみたところ、グラフィックドライバの適用が不可能、内蔵ドライブのeMMCを認識していない、など致命的な欠陥が明らかになった。32bitでダメなら64bitなんていけるはずもないので、追加の検証はせず、CSMWrapの利用は諦めることにした。

## 純正のCSMを有効化してみる

設定画面にないだけで、機能としては存在している可能性
有効化してみたが、レガシBIOS仕様のドライブから起動することはできなかった。UEFIのエントリが消えていたので設定変更自体はできていると思われる。
どこから手をつければいいのか見当もつかないため、一旦見なかったことにする。

## Linux

WindowsがダメならばLinuxを使えばよいじゃないということで、Arch Linuxの起動を試す。Arch LinuxやDebianは32bit UEFIでの64bitカーネル起動をサポートしている。ここでも様々な問題が発生し、また、本家とArch Linux 32とで挙動が異なった。

### Arch Linux 32のUEFIブート

そもそもの仕様としてArch Linux 32の公式ISOにはUEFIのブートローダは含まれていない。しかし、本家からsystemd-bootをコピーし、設定ファイルを若干書き変えることでUEFIブートすることができる。また、本家と違い標準ではrootfsがRAMにコピーされずUSBドライブを占有するが、カーネルパラメータに`copytoram`をつけることで本家と同様の挙動になる。正常に動作するUSBハブがなくてもUSBキーボードを接続できるようになる。

### 対策なし

何もせずに起動してみると、32bit版では起動開始から画面が流れ始めるまでに30秒ほど固まったが、待ちさえすれば起動した。しかし、64bit版ではいくら待っても起動しなかった。

とりあえず起動できる32bit版で詳細なログを取ろうと`debug efi=debug log_buf_len=4M`をつけ、起動後に`dmesg`で確認してみたが、明らかにタイムスタンプが実時間を反映していないことが分かった。

`earlycon=efifb keep_bootcon`をつけて初期からリアルタイムでログを見られるようにしてみたところ、以下のように途中で処理が止まっているにも関わらず、タイムスタンプは進んでいないことが分かった。64bit版でも同じような表示で固まった。なお、`initcall_debug`を使ってみても、時間のかかっている関数はなかった。

```
...
[    0.488003] efi: EFI runtime memory map:
[    0.488024] efi: mem00: [Boot Data   |RUN|  |  |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x00000000b71ba000-0x00000000b7203fff] (0MB)
[    0.488052] efi: mem01: [Runtime Code|RUN|  |  |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x00000000b8172000-0x00000000b8371fff] (2MB)
[    0.488077] efi: mem02: [Runtime Data|RUN|  |  |  |  |  |  |  |  |   |WB|WT|WC|UC] range=[0x00000000b8372000-0x00000000b8671fff] (3MB)
[    0.488103] efi: mem03: [MMIO        |RUN|  |  |  |  |  |  |  |  |   |  |  |  |UC] range=[0x00000000e00f8000-0x00000000e00f8fff] (0MB)
[    0.488128] efi: mem04: [MMIO        |RUN|  |  |  |  |  |  |  |  |   |  |  |  |  ] range=[0x00000000fed01000-0x00000000fed01fff] (0MB)
[    0.488153] efi: mem05: [MMIO        |RUN|  |  |  |  |  |  |  |  |   |  |  |  |  ] range=[0x00000000ffd00000-0x00000000ffffffff] (3MB)
(ここで現実には約30秒間停止)
[    0.489334] LSM: initializing lsm=capability,landlock,lockdown,yama
[    0.489334] landlock: Up and running.
[    0.489334] Yama: becoming mindful.
...
```

### EFIランタイム無効化

UEFIが問題っぽいので、`noefi`や`efi=noruntime`をつけてEFIランタイムを無効化してみた。すると、32bit版では待ち時間がなくなり、64bit版も起動できるようになった。

これで万事解決、というわけではなく、副作用も発生した。

まず、Wi-Fiが動作しなくなった。Wi-Fiの動作にファームウェアがNVRAMで提供する情報が必要だが、EFIなしではこれが取得できないためのようである。これは容易に解決でき、EFIランタイムを有効にした32bit環境で`/sys/firmware/efi/efivars/nvram-74b00bd9-805a-4d61-b51f-43268123d113`をファイルに書き出し、それを`/lib/firmware/brcm/brcmfmac43241b4-sdio.txt`に配置すればよい。ライブ環境では以下の手順で再読み込みさせる。

```bash
modprobe -r brcmfmac
modprobe brcmfmac
systemctl restart iwd
```

さらに、シャットダウン後に電源が切れなくなった。画面は消え、USBコントローラも停止してキーボードのランプは消え、外見ではほぼ分からないが、USBの5 Vは出力されていて、スタートボタンに触れるとバイブが鳴り、バッテリはしっかり減っていく状態になる。電源ボタンを10秒長押しして強制的に電源を落とす必要がある。`reboot=pci`を追加したところ、再起動はできるようになったが、シャットダウンの改善はできなかった。

### TPM無効化

EFIランタイム無効化で64bit版も起動できるようになったが、32bit版では発生しない問題として、起動処理の最後のほうで`/dev/tpmrm0`をタイムアウトするまで待ち続けるという現象が発生した。`initcall_blacklist=tpm_init`によりTPMを完全に無効化することで解消できた。

### GUI環境

インストーラが起動できたので、ライブ環境では検証できないGUIの使い心地などを確かめるために、実際にインストールしてみた。内蔵eMMCは破壊したくないが、普通のUSBメモリではまともに動作せず、SSDからUSBに変換するやつはUEFIが認識しなかったので、カメラ用の比較的高速な記録メディアであるCFカードをUSBカードリーダ経由で接続した。

いつも通りKDE Plasmaをインストールしたところ、とりあえずタッチパネルは動作して使用することができた。ログイン画面のSDDMとログイン後のKDE環境とでそれぞれArchWikiに従って仮想キーボードを有効にすると、とりあえず文字入力もできるようになった。

しかし、KDEで指示されている`maliit-keyboard`なる仮想キーボードの出来がかなり悪く、さらには日本語入力もできない(できると主張しているが`anthy`を入れろ以外の情報がなく入れても何も起こらないので謎)ため、とても実用できるものではない。

これを抜きにしても、UI全体がタッチパネルでは使いにくく、そもそも全体的に動きがWindows 10よりももっさりしており、わざわざこのPCを使い続けるほどの価値があるような環境は実現できなかった。


## Windows 10 32bit

64bit版OSがどれも実用的でないので、ひとまず32bit版のWindows 10を使い続けることにした。すでにインストールされていて破壊もしていないので何もいじる必要はないのだが、𝑊𝑖𝑛𝑑𝑜𝑤𝑠 𝐼𝑛𝑠𝑡𝑎𝑙𝑙 𝐵𝑎𝑡𝑡𝑙𝑒をしたい気分なのと、将来Linuxを入れるときにESPが大きいほうが嬉しいので、一旦破壊してクリーンインストールすることにした。

実はMicrosoft公式配布のISOはあまり更新されておらず、時期によってはインストール直後に数回のWindows Updateが必要になる。通常は一瞬で終わるので気にしていなかったが、Atomではかなりの時間がかかる。[UUPDump](https://uupdump.net/known.php?q=19045+x86)を使って更新適用済みのISOを生成すると時短になる。

インストール環境を起動するには、音量下を押しながら起動(ロゴが出たら離してよい)でUSBドライブから起動できる。インストール環境でも普通にタッチパネルが動作するので、キーボードの接続は不要。なお、USBドライブからの起動に失敗するとブートエントリの一覧が出て、また、音量上を押しながらでファームウェア設定画面が出る。

タッチキーボードはWindows 11より使いやすく、動作もAtom+eMMCの割にはまあまあ軽快で、モダンスタンバイ(Suspend to idle)に対応していて、実用上の問題はほぼない。唯一にして致命的な欠点は、サポート終了が迫っていることである。


ドライバは[公式サイト](https://jp.sharp/support/mebiuspad/)からすべてダウンロードできる。実行すると`C:\Program Files\Sharp`に展開されるので、一部のみインストールすることもできる。なぜかカメラのドライバに「Intel(R) AVStream Camera」が適用された状態になるが、これでは動作せず、[Sigezoneのツイート](https://x.com/ShigezoneAkiba/status/1563339722482937857)を参考に「Intel(R) Imaging Signal Processor 2400」のほうを適用しなおすと動作した。


プリインストールのCPInterfaceとアップデートのIntelのWCEのドライバは、公式サイトの説明には載っておらず、適用しなくてもデバイスマネージャに警告は残らず謎である。

カメラセンサ(IMX175、OV2722)、NFC、Intel DPT、Intel TXE以外は、Intel HD Graphicsは通常のWindows Updateで、それ以外はオプションの更新プログラムで公式配布のものより新しいものが適用された。しかし、Windows Updateをすべて適用してから残りに手動でメーカー配布ドライバを適用するという手順を踏んだところ、カメラの起動がとても遅くなったり、音声出力が機能しなくなったりした。

Windows UpdateでIntel HD Graphicsのドライバだけ適用した後、アップデートのGFX以外のドライバを手動で適用(`.inf`ファイルを右クリックしてインストール)するのが無難である。

Intel関連のドライバは、アップデートのほうにプリインストールのものも全て含まれている。インストーラでは一部がインストールされない。

PMICのドライバが当たる前は電源ボタンが機能せず、モダンスタンバイからの復帰ができない。電源ボタンを押してもスリープしなくなった場合は、一時的に自動スリープを無効化して詰むのを防ぐとよい。休止状態からの復帰はできる。

Intel HD 10.18.10.4252

Broadcom Windows標準 5.93.102.22

システムの詳細設定でフォントのアンチエイリアス以外のすべての視覚効果を無効にしたり、透過を無効にしたりなどの懐かしいチューニング(笑)を行うと快適さが向上する、気がする。PowerShellの起動が遅いのでWin+Xメニューに出るのをコマンドプロンプトにしたりなどするとよい。ドライバやアップデートのインストール時はリアルタイム保護を無効にすると速くなる。

## あとがき

結局、Windows 10のESUが続いてる間はそのまま使い続けるのが無難であるという結論であった。

## 付録: 機能しなかったカーネルパラメータ一覧

Linuxの不具合を解決するために、ログをChatGPTに投げつけたりして色々と試したが、ほとんどは効果がなかった。機能しない、というのも重要な情報であるので、ここにまとめておく。

32bitでの起動遅延、64bitでの起動不可を解決しなかったパラメータは以下。

- `efi=disable_early_pci_dma`
- `efi=nochunk`
- `efi=nosoftreserve`
- `efi=novamap`
- `efi=no_disable_early_pci_dma`
- `efi=old_map` (昔はこれでいけてたが削除されたらしい。なぜ……)
- `acpi_force_32bit_fadt_addr`
- `mem=nopentium`
- `arch=i686`

共通してシャットダウン問題を解決しなかったパラメータは以下。

- `reboot=efi`
- `reboot=acpi`
- `reboot=pci` (再起動は可)
- `shutdown=pci`
- `acpi=force acpi_osi=Linux`
- `apm=power_off`

64bitでのTPMの遅延を解決しなかったパラメータは以下。

- `tpm_tis.force=1 tpm_tis.interrupts=0`
- `tpm=off`
